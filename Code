// SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;


//Registration Smart contract

contract Registration {
    
    address public Regulator; //Ethereum address of the regulator
    mapping(address => bool) public manufacturer; //a mapping that lists all authorized manufacturers
    mapping(address => bool) public distributor; //a mapping that lists all authorized distributors
    mapping(address => bool)  public healthcarecenter; //a mapping for all authorized healthcare centers
    
    //Registration Events
    
    event RegistrationSCDeployer(address indexed Regulator); //An event to show the address of the registration SC deployer
    event ManufacturerRegistered(address indexed Regulator, address indexed manufacturer);
    event DistributorRegistered(address indexed Regulator, address indexed distributor);
    event HealthCareCenterRegistered(address indexed Regulator, address indexed healthcarecenter);


    //Modifiers
    
    modifier onlyRegulator() {
        require(Regulator == msg.sender, "Only the Regulator is eligible to run this function");
        _;
    }
    
    modifier onlyhealthcarecenter{
        require(healthcarecenter[msg.sender] , "Only the healthcare center is eligible to run this function");
        _;
    }
    
    //Creating the contract constructor

    constructor() {
        
        Regulator = msg.sender; //The regulator is the deployer of the registration SC
        emit RegistrationSCDeployer(Regulator);

    }
    
    //Registration Functions
    
    function manufacturerRegistration (address user) public onlyRegulator {
        require(manufacturer[user] == false, "The user is already registered");
        manufacturer[user] = true;
        emit ManufacturerRegistered(msg.sender, user);

    }
    
    function distributorRegistration (address user) public onlyRegulator {
        require(distributor[user] == false, "The user is already registered");
        distributor[user] = true;
        emit DistributorRegistered(msg.sender, user);
    }

    function healthcarecenterRegistration (address user) public onlyRegulator{
        require(healthcarecenter[user] == false, "The user is already registered");
        healthcarecenter[user] = true;
        emit HealthCareCenterRegistered(msg.sender, user);
    }
    
    
}



//Commitment Smart contract

import "@chainlink/contracts/src/v0.7/KeeperCompatible.sol";

contract Commitment is KeeperCompatibleInterface {
    
    //Declaring variables
    
    Registration public regcontract; //used to access variables and functions from the registration contract

    address public TrustedOracle; // The EA of the trusted oracle that is used to signal the end of the commitment window if needed
    uint public StartingTime; //Used to define the starting time of deploying the ordering SC
    uint public CommitmentDuration; //The time window of commitment
    uint public MaxVaccineBoxes; //The maximum amount of COVID-19 vaccine boxes that the manufacturer can produce within each Lot
    uint public MinThreshold; //The minimum threshold that should be met for the manufacturer to accept manufacturing

    mapping(address => bool) public CommittedDistributor; //A mapping to check if the distributor has already comitted to deliver the vaccine Lot
    bool public DistributorCommitted;

    mapping(address => HCPreference) public AffiliatedDistributor; //A mapping to choose the AffiliatedDistributor by the healthcare center
    struct HCPreference{
    address adistributor; //affiliated distributor EA
    bool affiliated; //used to check if the distributor has already been assigned as an affiliated distributor
    } 
    

    uint PlacedBidsCounter = 0; //Used to ensure the bids do not exceed the maximum
    uint public CurrentBids;
    mapping(address => bool) public BidderCommitted; //A mapping for healthcarecenters that have priority in orders

    bool public ProductionPermission; //Used to indicate if production is approved or denied
    bool public CommitmentWindow; //Used to all the oracle to execute once only
 


    
    //Commitment events

    event CommitmentDetails (address indexed _manufacturer, address indexed _vaccineLotEA, uint _MaxVaccineBoxes, uint _MinThreshold, uint _StartingTime, uint _CommitmentDuration); //An event to show the address of the commitment SC deployer and the MaxVaccineLotAmount
    event DistributorCommitmentDetails(address indexed _distributor, address indexed _vaccineLotEA);
    event HealthcareCenterCommitmentDetails(address indexed healthcarecenter, address indexed _vaccineLotEA, uint _placedorder);
    event VaccineLotsManufactured(address indexed manufacturer, uint indexed _ordernumber, uint _VaccineLotsProduced); //An event to confirm the manufacturing of the vaccine lots
    event CloseCommitmentWindow(address indexed _msgsender, bytes32 _windowclosed);
    event ProductionApproved(bytes32 _approved, uint _currentbids, address indexed _vaccineLotEA);
    event ProductionDenied(bytes32 _denied, uint _currentbids, address indexed _vaccineLotEA);


    //Modifiers 
    
    modifier onlyhealthcarecenter{

    require(regcontract.healthcarecenter(msg.sender), "Only the healthcarecenter is allowed to execute this function");
    _;
    }
    
    modifier onlymanufacturer{

    require(regcontract.manufacturer(msg.sender), "Only the manufacturer is allowed to execute this function");
    _;
    }
    
    modifier onlyDistributor{

    require(regcontract.distributor(msg.sender), "Only the distributor is allowed to execute this function");
    _;
    }

    modifier onlyTrustedOracle{

    require(TrustedOracle == msg.sender, "Only the Trusted Oracle is allowed to execute this function");
    _;
    }
    

    //Constructor
    
    constructor(address RegistrationSCaddress, uint _MaxVaccineBoxes, uint _MinThreshold, uint _CommitmentDuration) {
        
        regcontract = Registration(RegistrationSCaddress);
        CommitmentDuration =  _CommitmentDuration * 1 minutes; //It's assumed that the duration is the same for both the distributors and bidders
        MaxVaccineBoxes = _MaxVaccineBoxes;
        MinThreshold = _MinThreshold;
        StartingTime = block.timestamp;
        emit CommitmentDetails(msg.sender, address(this), MaxVaccineBoxes, MinThreshold, StartingTime, CommitmentDuration);
    } 
    
    //Functions
    
    //Distributor Commitment function
    function DistributorCommitment() public onlyDistributor{
        require(block.timestamp <= StartingTime + CommitmentDuration, "New commitments are no longer accepted as the time window is over");
        require(DistributorCommitted == false, "The vaccine Lot has already been committed to by another distributor ");

        CommittedDistributor[msg.sender] = true; //This boolean mapping is used to store the committed distributors
        DistributorCommitted = true; //this boolean indicates that a distributor has committed to deliver the vaccine Lot

        emit DistributorCommitmentDetails(msg.sender, address(this));
        
    }

    
    // This function is used to match the healthcare center to its affiliated distributor, the mapping links the address of the HCcenter with a struct with the details of the Affiliated distributor
    function AddAffiliatedDistributor (address _distributor) public onlyhealthcarecenter{ 
        require(!AffiliatedDistributor[msg.sender].affiliated, "This distributor has already been added to the affiliated list");
        AffiliatedDistributor[msg.sender].adistributor = _distributor;
        AffiliatedDistributor[msg.sender].affiliated = true;
    }
    
    //Healthcare centers commitment function
    function PlaceBid(uint _PlacedBid) public onlyhealthcarecenter{
        require(block.timestamp <= StartingTime + CommitmentDuration , "New bids are no longer accepted as the time window is over");
        //require(DistributorCommitted == true,"Cannot place bid because none of the distributors has committed to deliver the vaccine Lot");
        require(CommittedDistributor[AffiliatedDistributor[msg.sender].adistributor], "The affiliated distributor with this healthcare center has not committed to deliver this vaccine Lot");
        require(_PlacedBid + PlacedBidsCounter <= MaxVaccineBoxes, "The specified amount exceeds the maximum/remaining number of boxes within the vaccine Lot");
        require(!BidderCommitted[msg.sender], "This healthcare center has already placed a bid before");

        PlacedBidsCounter += _PlacedBid;
        CurrentBids = PlacedBidsCounter; //used because the counter is not public
        BidderCommitted[msg.sender] = true; //Used to ensure that the healthcare center does not place another bid

        if(CurrentBids != MaxVaccineBoxes){
            emit HealthcareCenterCommitmentDetails(msg.sender, address(this), _PlacedBid);
        } else if(CurrentBids >= MaxVaccineBoxes){
            emit HealthcareCenterCommitmentDetails(msg.sender, address(this), _PlacedBid);
            emit CloseCommitmentWindow(msg.sender, bytes32("Commitment Window is now closed"));
            emit ProductionApproved(bytes32("Production is approved"), CurrentBids, address(this));
            ProductionPermission = true;
        }
        
        
    }

    //TimerOracle function [Remove if the keeper network works]

    function CommitmentWindowClose() public onlyTrustedOracle{
        require(block.timestamp >= StartingTime + CommitmentDuration, "Can't announce the end of the commitment window before the time is up");
        emit CloseCommitmentWindow(msg.sender, bytes32("Commitment Window is now closed"));
        if(CurrentBids >= MinThreshold*MaxVaccineBoxes){
            emit ProductionApproved(bytes32("Production is approved"), CurrentBids, address(this));
            ProductionPermission = true;
        } else {
            emit ProductionDenied(bytes32("Production is denied"), CurrentBids, address(this));

        }
    }

    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {
        upkeepNeeded = (StartingTime + CommitmentDuration) < block.timestamp;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(bytes calldata /* performData */) external override {
        require(CommitmentWindow == false);
        if(CurrentBids >= MinThreshold*MaxVaccineBoxes){
            emit ProductionApproved(bytes32("Production is approved"), CurrentBids, address(this));
            ProductionPermission = true;
            CommitmentWindow = true;
        } else {
            emit ProductionDenied(bytes32("Production is denied"), CurrentBids, address(this));
            CommitmentWindow = true;
        
        }

        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

    
    //Used for testing purposes only
    function stringToBytes32(string memory source) public pure returns (bytes32 result) {
    bytes memory tempEmptyStringTest = bytes(source);
    if (tempEmptyStringTest.length == 0) {
        return 0x0;
    }

    assembly {
        result := mload(add(source, 32))
    }
    }
    
    

}
